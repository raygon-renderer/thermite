initSidebarItems({"constant":[["_CMP_EQ_OQ","Equal (ordered, non-signaling)"],["_CMP_EQ_OS","Equal (ordered, signaling)"],["_CMP_EQ_UQ","Equal (unordered, non-signaling)"],["_CMP_EQ_US","Equal (unordered, signaling)"],["_CMP_FALSE_OQ","False (ordered, non-signaling)"],["_CMP_FALSE_OS","False (ordered, signaling)"],["_CMP_GE_OQ","Greater-than-or-equal (ordered, non-signaling)"],["_CMP_GE_OS","Greater-than-or-equal (ordered, signaling)"],["_CMP_GT_OQ","Greater-than (ordered, non-signaling)"],["_CMP_GT_OS","Greater-than (ordered, signaling)"],["_CMP_LE_OQ","Less-than-or-equal (ordered, non-signaling)"],["_CMP_LE_OS","Less-than-or-equal (ordered, signaling)"],["_CMP_LT_OQ","Less-than (ordered, non-signaling)"],["_CMP_LT_OS","Less-than (ordered, signaling)"],["_CMP_NEQ_OQ","Not-equal (ordered, non-signaling)"],["_CMP_NEQ_OS","Not-equal (ordered, signaling)"],["_CMP_NEQ_UQ","Not-equal (unordered, non-signaling)"],["_CMP_NEQ_US","Not-equal (unordered, signaling)"],["_CMP_NGE_UQ","Not-greater-than-or-equal (unordered, non-signaling)"],["_CMP_NGE_US","Not-greater-than-or-equal (unordered, signaling)"],["_CMP_NGT_UQ","Not-greater-than (unordered, non-signaling)"],["_CMP_NGT_US","Not-greater-than (unordered, signaling)"],["_CMP_NLE_UQ","Not-less-than-or-equal (unordered, non-signaling)"],["_CMP_NLE_US","Not-less-than-or-equal (unordered, signaling)"],["_CMP_NLT_UQ","Not-less-than (unordered, non-signaling)"],["_CMP_NLT_US","Not-less-than (unordered, signaling)"],["_CMP_ORD_Q","Ordered (non-signaling)"],["_CMP_ORD_S","Ordered (signaling)"],["_CMP_TRUE_UQ","True (unordered, non-signaling)"],["_CMP_TRUE_US","True (unordered, signaling)"],["_CMP_UNORD_Q","Unordered (non-signaling)"],["_CMP_UNORD_S","Unordered (signaling)"],["_MM_FROUND_CEIL","round up and do not suppress exceptions"],["_MM_FROUND_CUR_DIRECTION","use MXCSR.RC; see `vendor::_MM_SET_ROUNDING_MODE`"],["_MM_FROUND_FLOOR","round down and do not suppress exceptions"],["_MM_FROUND_NEARBYINT","use MXCSR.RC and suppress exceptions; see `vendor::_MM_SET_ROUNDING_MODE`"],["_MM_FROUND_NINT","round to nearest and do not suppress exceptions"],["_MM_FROUND_NO_EXC","suppress exceptions"],["_MM_FROUND_RAISE_EXC","do not suppress exceptions"],["_MM_FROUND_RINT","use MXCSR.RC and do not suppress exceptions; see `vendor::_MM_SET_ROUNDING_MODE`"],["_MM_FROUND_TO_NEAREST_INT","round to nearest"],["_MM_FROUND_TO_NEG_INF","round down"],["_MM_FROUND_TO_POS_INF","round up"],["_MM_FROUND_TO_ZERO","truncate"],["_MM_FROUND_TRUNC","truncate and do not suppress exceptions"]],"fn":[["_mm_add_ps","Adds __m128 vectors."],["_mm_add_ss","Adds the first component of `a` and `b`, the other components are copied from `a`."],["_mm_and_ps","Bitwise AND of packed single-precision (32-bit) floating-point elements."],["_mm_andnot_ps","Bitwise AND-NOT of packed single-precision (32-bit) floating-point elements."],["_mm_cmpeq_ps","Compares each of the four floats in `a` to the corresponding element in `b`. The result in the output vector will be `0xffffffff` if the input elements were equal, or `0` otherwise."],["_mm_cmpeq_ss","Compares the lowest `f32` of both inputs for equality. The lowest 32 bits of the result will be `0xffffffff` if the two inputs are equal, or `0` otherwise. The upper 96 bits of the result are the upper 96 bits of `a`."],["_mm_cmpge_ps","Compares each of the four floats in `a` to the corresponding element in `b`. The result in the output vector will be `0xffffffff` if the input element in `a` is greater than or equal to the corresponding element in `b`, or `0` otherwise."],["_mm_cmpge_ss","Compares the lowest `f32` of both inputs for greater than or equal. The lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is greater than or equal `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result are the upper 96 bits of `a`."],["_mm_cmpgt_ps","Compares each of the four floats in `a` to the corresponding element in `b`. The result in the output vector will be `0xffffffff` if the input element in `a` is greater than the corresponding element in `b`, or `0` otherwise."],["_mm_cmpgt_ss","Compares the lowest `f32` of both inputs for greater than. The lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is greater than `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result are the upper 96 bits of `a`."],["_mm_cmple_ps","Compares each of the four floats in `a` to the corresponding element in `b`. The result in the output vector will be `0xffffffff` if the input element in `a` is less than or equal to the corresponding element in `b`, or `0` otherwise."],["_mm_cmple_ss","Compares the lowest `f32` of both inputs for less than or equal. The lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is less than or equal `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result are the upper 96 bits of `a`."],["_mm_cmplt_ps","Compares each of the four floats in `a` to the corresponding element in `b`. The result in the output vector will be `0xffffffff` if the input element in `a` is less than the corresponding element in `b`, or `0` otherwise."],["_mm_cmplt_ss","Compares the lowest `f32` of both inputs for less than. The lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is less than `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result are the upper 96 bits of `a`."],["_mm_cmpneq_ps","Compares each of the four floats in `a` to the corresponding element in `b`. The result in the output vector will be `0xffffffff` if the input elements are not equal, or `0` otherwise."],["_mm_cmpneq_ss","Compares the lowest `f32` of both inputs for inequality. The lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is not equal to `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result are the upper 96 bits of `a`."],["_mm_cmpnge_ps","Compares each of the four floats in `a` to the corresponding element in `b`. The result in the output vector will be `0xffffffff` if the input element in `a` is not greater than or equal to the corresponding element in `b`, or `0` otherwise."],["_mm_cmpnge_ss","Compares the lowest `f32` of both inputs for not-greater-than-or-equal. The lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is not greater than or equal to `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result are the upper 96 bits of `a`."],["_mm_cmpngt_ps","Compares each of the four floats in `a` to the corresponding element in `b`. The result in the output vector will be `0xffffffff` if the input element in `a` is not greater than the corresponding element in `b`, or `0` otherwise."],["_mm_cmpngt_ss","Compares the lowest `f32` of both inputs for not-greater-than. The lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is not greater than `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result are the upper 96 bits of `a`."],["_mm_cmpnle_ps","Compares each of the four floats in `a` to the corresponding element in `b`. The result in the output vector will be `0xffffffff` if the input element in `a` is not less than or equal to the corresponding element in `b`, or `0` otherwise."],["_mm_cmpnle_ss","Compares the lowest `f32` of both inputs for not-less-than-or-equal. The lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is not less than or equal to `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result are the upper 96 bits of `a`."],["_mm_cmpnlt_ps","Compares each of the four floats in `a` to the corresponding element in `b`. The result in the output vector will be `0xffffffff` if the input element in `a` is not less than the corresponding element in `b`, or `0` otherwise."],["_mm_cmpnlt_ss","Compares the lowest `f32` of both inputs for not-less-than. The lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is not less than `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result are the upper 96 bits of `a`."],["_mm_cmpord_ps","Compares each of the four floats in `a` to the corresponding element in `b`. Returns four floats that have one of two possible bit patterns. The element in the output vector will be `0xffffffff` if the input elements in `a` and `b` are ordered (i.e., neither of them is a NaN), or 0 otherwise."],["_mm_cmpord_ss","Checks if the lowest `f32` of both inputs are ordered. The lowest 32 bits of the result will be `0xffffffff` if neither of `a.extract(0)` or `b.extract(0)` is a NaN, or `0` otherwise. The upper 96 bits of the result are the upper 96 bits of `a`."],["_mm_cmpunord_ps","Compares each of the four floats in `a` to the corresponding element in `b`. Returns four floats that have one of two possible bit patterns. The element in the output vector will be `0xffffffff` if the input elements in `a` and `b` are unordered (i.e., at least on of them is a NaN), or 0 otherwise."],["_mm_cmpunord_ss","Checks if the lowest `f32` of both inputs are unordered. The lowest 32 bits of the result will be `0xffffffff` if any of `a.extract(0)` or `b.extract(0)` is a NaN, or `0` otherwise. The upper 96 bits of the result are the upper 96 bits of `a`."],["_mm_comieq_ss","Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns `1` if they are equal, or `0` otherwise."],["_mm_comige_ss","Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns `1` if the value from `a` is greater than or equal to the one from `b`, or `0` otherwise."],["_mm_comigt_ss","Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns `1` if the value from `a` is greater than the one from `b`, or `0` otherwise."],["_mm_comile_ss","Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns `1` if the value from `a` is less than or equal to the one from `b`, or `0` otherwise."],["_mm_comilt_ss","Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns `1` if the value from `a` is less than the one from `b`, or `0` otherwise."],["_mm_comineq_ss","Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns `1` if they are not equal, or `0` otherwise."],["_mm_cvt_si2ss","Alias for `_mm_cvtsi32_ss`."],["_mm_cvt_ss2si","Alias for `_mm_cvtss_si32`."],["_mm_cvtsi32_ss","Converts a 32 bit integer to a 32 bit float. The result vector is the input vector `a` with the lowest 32 bit float replaced by the converted integer."],["_mm_cvtsi64_ss","Converts a 64 bit integer to a 32 bit float. The result vector is the input vector `a` with the lowest 32 bit float replaced by the converted integer."],["_mm_cvtss_f32","Extracts the lowest 32 bit float from the input vector."],["_mm_cvtss_si32","Converts the lowest 32 bit float in the input vector to a 32 bit integer."],["_mm_cvtss_si64","Converts the lowest 32 bit float in the input vector to a 64 bit integer."],["_mm_cvtt_ss2si","Alias for `_mm_cvttss_si32`."],["_mm_cvttss_si32","Converts the lowest 32 bit float in the input vector to a 32 bit integer with truncation."],["_mm_cvttss_si64","Converts the lowest 32 bit float in the input vector to a 64 bit integer with truncation."],["_mm_div_ps","Divides __m128 vectors."],["_mm_div_ss","Divides the first component of `b` by `a`, the other components are copied from `a`."],["_mm_load1_ps","Construct a `__m128` by duplicating the value read from `p` into all elements."],["_mm_load_ps","Loads four `f32` values from aligned memory into a `__m128`. If the pointer is not aligned to a 128-bit boundary (16 bytes) a general protection fault will be triggered (fatal program crash)."],["_mm_load_ps1","Alias for `_mm_load1_ps`"],["_mm_load_ss","Construct a `__m128` with the lowest element read from `p` and the other elements set to zero."],["_mm_loadr_ps","Loads four `f32` values from aligned memory into a `__m128` in reverse order."],["_mm_loadu_ps","Loads four `f32` values from memory into a `__m128`. There are no restrictions on memory alignment. For aligned memory `_mm_load_ps` may be faster."],["_mm_loadu_si64","Loads unaligned 64-bits of integer data from memory into new vector."],["_mm_max_ps","Compares packed single-precision (32-bit) floating-point elements in `a` and `b`, and return the corresponding maximum values."],["_mm_max_ss","Compares the first single-precision (32-bit) floating-point element of `a` and `b`, and return the maximum value in the first element of the return value, the other elements are copied from `a`."],["_mm_min_ps","Compares packed single-precision (32-bit) floating-point elements in `a` and `b`, and return the corresponding minimum values."],["_mm_min_ss","Compares the first single-precision (32-bit) floating-point element of `a` and `b`, and return the minimum value in the first element of the return value, the other elements are copied from `a`."],["_mm_move_ss","Returns a `__m128` with the first component from `b` and the remaining components from `a`."],["_mm_movehl_ps","Combine higher half of `a` and `b`. The highwe half of `b` occupies the lower half of result."],["_mm_movelh_ps","Combine lower half of `a` and `b`. The lower half of `b` occupies the higher half of result."],["_mm_movemask_ps","Returns a mask of the most significant bit of each element in `a`."],["_mm_mul_ps","Multiplies __m128 vectors."],["_mm_mul_ss","Multiplies the first component of `a` and `b`, the other components are copied from `a`."],["_mm_or_ps","Bitwise OR of packed single-precision (32-bit) floating-point elements."],["_mm_prefetch","Fetch the cache line that contains address `p` using the given `STRATEGY`."],["_mm_rcp_ps","Returns the approximate reciprocal of packed single-precision (32-bit) floating-point elements in `a`."],["_mm_rcp_ss","Returns the approximate reciprocal of the first single-precision (32-bit) floating-point element in `a`, the other elements are unchanged."],["_mm_rsqrt_ps","Returns the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in `a`."],["_mm_rsqrt_ss","Returns the approximate reciprocal square root of the first single-precision (32-bit) floating-point element in `a`, the other elements are unchanged."],["_mm_set1_ps","Construct a `__m128` with all element set to `a`."],["_mm_set_ps","Construct a `__m128` from four floating point values highest to lowest."],["_mm_set_ps1","Alias for `_mm_set1_ps`"],["_mm_set_ss","Construct a `__m128` with the lowest element set to `a` and the rest set to zero."],["_mm_setcsr","Sets the MXCSR register with the 32-bit unsigned integer value."],["_mm_setr_ps","Construct a `__m128` from four floating point values lowest to highest."],["_mm_setzero_ps","Construct a `__m128` with all elements initialized to zero."],["_mm_sfence","Performs a serializing operation on all store-to-memory instructions that were issued prior to this instruction."],["_mm_shuffle_ps","Shuffles packed single-precision (32-bit) floating-point elements in `a` and `b` using `MASK`."],["_mm_sqrt_ps","Returns the square root of packed single-precision (32-bit) floating-point elements in `a`."],["_mm_sqrt_ss","Returns the square root of the first single-precision (32-bit) floating-point element in `a`, the other elements are unchanged."],["_mm_store1_ps","Stores the lowest 32 bit float of `a` repeated four times into aligned memory."],["_mm_store_ps","Stores four 32-bit floats into aligned memory."],["_mm_store_ps1","Alias for `_mm_store1_ps`"],["_mm_store_ss","Stores the lowest 32 bit float of `a` into memory."],["_mm_storer_ps","Stores four 32-bit floats into aligned memory in reverse order."],["_mm_storeu_ps","Stores four 32-bit floats into memory. There are no restrictions on memory alignment. For aligned memory `_mm_store_ps` may be faster."],["_mm_stream_ps","Stores `a` into the memory at `mem_addr` using a non-temporal memory hint."],["_mm_sub_ps","Subtracts __m128 vectors."],["_mm_sub_ss","Subtracts the first component of `b` from `a`, the other components are copied from `a`."],["_mm_ucomieq_ss","Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns `1` if they are equal, or `0` otherwise. This instruction will not signal an exception if either argument is a quiet NaN."],["_mm_ucomige_ss","Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns `1` if the value from `a` is greater than or equal to the one from `b`, or `0` otherwise. This instruction will not signal an exception if either argument is a quiet NaN."],["_mm_ucomigt_ss","Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns `1` if the value from `a` is greater than the one from `b`, or `0` otherwise. This instruction will not signal an exception if either argument is a quiet NaN."],["_mm_ucomile_ss","Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns `1` if the value from `a` is less than or equal to the one from `b`, or `0` otherwise. This instruction will not signal an exception if either argument is a quiet NaN."],["_mm_ucomilt_ss","Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns `1` if the value from `a` is less than the one from `b`, or `0` otherwise. This instruction will not signal an exception if either argument is a quiet NaN."],["_mm_ucomineq_ss","Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns `1` if they are not equal, or `0` otherwise. This instruction will not signal an exception if either argument is a quiet NaN."],["_mm_undefined_ps","Returns vector of type __m128 with undefined elements."],["_mm_unpackhi_ps","Unpacks and interleave single-precision (32-bit) floating-point elements from the higher half of `a` and `b`."],["_mm_unpacklo_ps","Unpacks and interleave single-precision (32-bit) floating-point elements from the lower half of `a` and `b`."],["_mm_xor_ps","Bitwise exclusive OR of packed single-precision (32-bit) floating-point elements."]],"struct":[["__m128","128-bit wide set of four `f32` types, x86-specific"],["__m128d","128-bit wide set of two `f64` types, x86-specific"],["__m128i","128-bit wide integer vector type, x86-specific"]]});