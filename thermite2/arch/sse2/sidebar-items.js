initSidebarItems({"fn":[["_mm_add_epi16","Adds packed 16-bit integers in `a` and `b`."],["_mm_add_epi32","Adds packed 32-bit integers in `a` and `b`."],["_mm_add_epi64","Adds packed 64-bit integers in `a` and `b`."],["_mm_add_epi8","Adds packed 8-bit integers in `a` and `b`."],["_mm_add_pd","Adds packed double-precision (64-bit) floating-point elements in `a` and `b`."],["_mm_add_sd","Returns a new vector with the low element of `a` replaced by the sum of the low elements of `a` and `b`."],["_mm_adds_epi16","Adds packed 16-bit integers in `a` and `b` using saturation."],["_mm_adds_epi8","Adds packed 8-bit integers in `a` and `b` using saturation."],["_mm_adds_epu16","Adds packed unsigned 16-bit integers in `a` and `b` using saturation."],["_mm_adds_epu8","Adds packed unsigned 8-bit integers in `a` and `b` using saturation."],["_mm_and_pd","Computes the bitwise AND of packed double-precision (64-bit) floating-point elements in `a` and `b`."],["_mm_and_si128","Computes the bitwise AND of 128 bits (representing integer data) in `a` and `b`."],["_mm_andnot_pd","Computes the bitwise NOT of `a` and then AND with `b`."],["_mm_andnot_si128","Computes the bitwise NOT of 128 bits (representing integer data) in `a` and then AND with `b`."],["_mm_avg_epu16","Averages packed unsigned 16-bit integers in `a` and `b`."],["_mm_avg_epu8","Averages packed unsigned 8-bit integers in `a` and `b`."],["_mm_bslli_si128","Shifts `a` left by `IMM8` bytes while shifting in zeros."],["_mm_bsrli_si128","Shifts `a` right by `IMM8` bytes while shifting in zeros."],["_mm_castpd_ps","Casts a 128-bit floating-point vector of `[2 x double]` into a 128-bit floating-point vector of `[4 x float]`."],["_mm_castpd_si128","Casts a 128-bit floating-point vector of `[2 x double]` into a 128-bit integer vector."],["_mm_castps_pd","Casts a 128-bit floating-point vector of `[4 x float]` into a 128-bit floating-point vector of `[2 x double]`."],["_mm_castps_si128","Casts a 128-bit floating-point vector of `[4 x float]` into a 128-bit integer vector."],["_mm_castsi128_pd","Casts a 128-bit integer vector into a 128-bit floating-point vector of `[2 x double]`."],["_mm_castsi128_ps","Casts a 128-bit integer vector into a 128-bit floating-point vector of `[4 x float]`."],["_mm_clflush","Invalidates and flushes the cache line that contains `p` from all levels of the cache hierarchy."],["_mm_cmpeq_epi16","Compares packed 16-bit integers in `a` and `b` for equality."],["_mm_cmpeq_epi32","Compares packed 32-bit integers in `a` and `b` for equality."],["_mm_cmpeq_epi8","Compares packed 8-bit integers in `a` and `b` for equality."],["_mm_cmpeq_pd","Compares corresponding elements in `a` and `b` for equality."],["_mm_cmpeq_sd","Returns a new vector with the low element of `a` replaced by the equality comparison of the lower elements of `a` and `b`."],["_mm_cmpge_pd","Compares corresponding elements in `a` and `b` for greater-than-or-equal."],["_mm_cmpge_sd","Returns a new vector with the low element of `a` replaced by the greater-than-or-equal comparison of the lower elements of `a` and `b`."],["_mm_cmpgt_epi16","Compares packed 16-bit integers in `a` and `b` for greater-than."],["_mm_cmpgt_epi32","Compares packed 32-bit integers in `a` and `b` for greater-than."],["_mm_cmpgt_epi8","Compares packed 8-bit integers in `a` and `b` for greater-than."],["_mm_cmpgt_pd","Compares corresponding elements in `a` and `b` for greater-than."],["_mm_cmpgt_sd","Returns a new vector with the low element of `a` replaced by the greater-than comparison of the lower elements of `a` and `b`."],["_mm_cmple_pd","Compares corresponding elements in `a` and `b` for less-than-or-equal"],["_mm_cmple_sd","Returns a new vector with the low element of `a` replaced by the less-than-or-equal comparison of the lower elements of `a` and `b`."],["_mm_cmplt_epi16","Compares packed 16-bit integers in `a` and `b` for less-than."],["_mm_cmplt_epi32","Compares packed 32-bit integers in `a` and `b` for less-than."],["_mm_cmplt_epi8","Compares packed 8-bit integers in `a` and `b` for less-than."],["_mm_cmplt_pd","Compares corresponding elements in `a` and `b` for less-than."],["_mm_cmplt_sd","Returns a new vector with the low element of `a` replaced by the less-than comparison of the lower elements of `a` and `b`."],["_mm_cmpneq_pd","Compares corresponding elements in `a` and `b` for not-equal."],["_mm_cmpneq_sd","Returns a new vector with the low element of `a` replaced by the not-equal comparison of the lower elements of `a` and `b`."],["_mm_cmpnge_pd","Compares corresponding elements in `a` and `b` for not-greater-than-or-equal."],["_mm_cmpnge_sd","Returns a new vector with the low element of `a` replaced by the not-greater-than-or-equal comparison of the lower elements of `a` and `b`."],["_mm_cmpngt_pd","Compares corresponding elements in `a` and `b` for not-greater-than."],["_mm_cmpngt_sd","Returns a new vector with the low element of `a` replaced by the not-greater-than comparison of the lower elements of `a` and `b`."],["_mm_cmpnle_pd","Compares corresponding elements in `a` and `b` for not-less-than-or-equal."],["_mm_cmpnle_sd","Returns a new vector with the low element of `a` replaced by the not-less-than-or-equal comparison of the lower elements of `a` and `b`."],["_mm_cmpnlt_pd","Compares corresponding elements in `a` and `b` for not-less-than."],["_mm_cmpnlt_sd","Returns a new vector with the low element of `a` replaced by the not-less-than comparison of the lower elements of `a` and `b`."],["_mm_cmpord_pd","Compares corresponding elements in `a` and `b` to see if neither is `NaN`."],["_mm_cmpord_sd","Returns a new vector with the low element of `a` replaced by the result of comparing both of the lower elements of `a` and `b` to `NaN`. If neither are equal to `NaN` then `0xFFFFFFFFFFFFFFFF` is used and `0` otherwise."],["_mm_cmpunord_pd","Compares corresponding elements in `a` and `b` to see if either is `NaN`."],["_mm_cmpunord_sd","Returns a new vector with the low element of `a` replaced by the result of comparing both of the lower elements of `a` and `b` to `NaN`. If either is equal to `NaN` then `0xFFFFFFFFFFFFFFFF` is used and `0` otherwise."],["_mm_comieq_sd","Compares the lower element of `a` and `b` for equality."],["_mm_comige_sd","Compares the lower element of `a` and `b` for greater-than-or-equal."],["_mm_comigt_sd","Compares the lower element of `a` and `b` for greater-than."],["_mm_comile_sd","Compares the lower element of `a` and `b` for less-than-or-equal."],["_mm_comilt_sd","Compares the lower element of `a` and `b` for less-than."],["_mm_comineq_sd","Compares the lower element of `a` and `b` for not-equal."],["_mm_cvtepi32_pd","Converts the lower two packed 32-bit integers in `a` to packed double-precision (64-bit) floating-point elements."],["_mm_cvtepi32_ps","Converts packed 32-bit integers in `a` to packed single-precision (32-bit) floating-point elements."],["_mm_cvtpd_epi32","Converts packed double-precision (64-bit) floating-point elements in `a` to packed 32-bit integers."],["_mm_cvtpd_ps","Converts packed double-precision (64-bit) floating-point elements in `a` to packed single-precision (32-bit) floating-point elements"],["_mm_cvtps_epi32","Converts packed single-precision (32-bit) floating-point elements in `a` to packed 32-bit integers."],["_mm_cvtps_pd","Converts packed single-precision (32-bit) floating-point elements in `a` to packed double-precision (64-bit) floating-point elements."],["_mm_cvtsd_f64","Returns the lower double-precision (64-bit) floating-point element of `a`."],["_mm_cvtsd_si32","Converts the lower double-precision (64-bit) floating-point element in a to a 32-bit integer."],["_mm_cvtsd_ss","Converts the lower double-precision (64-bit) floating-point element in `b` to a single-precision (32-bit) floating-point element, store the result in the lower element of the return value, and copies the upper element from `a` to the upper element the return value."],["_mm_cvtsi128_si32","Returns the lowest element of `a`."],["_mm_cvtsi128_si64","Returns the lowest element of `a`."],["_mm_cvtsi128_si64x","Returns the lowest element of `a`."],["_mm_cvtsi32_sd","Returns `a` with its lower element replaced by `b` after converting it to an `f64`."],["_mm_cvtsi32_si128","Returns a vector whose lowest element is `a` and all higher elements are `0`."],["_mm_cvtsi64x_si128","Returns a vector whose lowest element is `a` and all higher elements are `0`."],["_mm_cvtss_sd","Converts the lower single-precision (32-bit) floating-point element in `b` to a double-precision (64-bit) floating-point element, store the result in the lower element of the return value, and copies the upper element from `a` to the upper element the return value."],["_mm_cvttpd_epi32","Converts packed double-precision (64-bit) floating-point elements in `a` to packed 32-bit integers with truncation."],["_mm_cvttps_epi32","Converts packed single-precision (32-bit) floating-point elements in `a` to packed 32-bit integers with truncation."],["_mm_cvttsd_si32","Converts the lower double-precision (64-bit) floating-point element in `a` to a 32-bit integer with truncation."],["_mm_cvttsd_si64","Converts the lower double-precision (64-bit) floating-point element in `a` to a 64-bit integer with truncation."],["_mm_cvttsd_si64x","Alias for `_mm_cvttsd_si64`"],["_mm_div_pd","Divide packed double-precision (64-bit) floating-point elements in `a` by packed elements in `b`."],["_mm_div_sd","Returns a new vector with the low element of `a` replaced by the result of diving the lower element of `a` by the lower element of `b`."],["_mm_extract_epi16","Returns the `imm8` element of `a`."],["_mm_insert_epi16","Returns a new vector where the `imm8` element of `a` is replaced with `i`."],["_mm_lfence","Performs a serializing operation on all load-from-memory instructions that were issued prior to this instruction."],["_mm_load1_pd","Loads a double-precision (64-bit) floating-point element from memory into both elements of returned vector."],["_mm_load_pd","Loads 128-bits (composed of 2 packed double-precision (64-bit) floating-point elements) from memory into the returned vector. `mem_addr` must be aligned on a 16-byte boundary or a general-protection exception may be generated."],["_mm_load_pd1","Loads a double-precision (64-bit) floating-point element from memory into both elements of returned vector."],["_mm_load_sd","Loads a 64-bit double-precision value to the low element of a 128-bit integer vector and clears the upper element."],["_mm_load_si128","Loads 128-bits of integer data from memory into a new vector."],["_mm_loadh_pd","Loads a double-precision value into the high-order bits of a 128-bit vector of `[2 x double]`. The low-order bits are copied from the low-order bits of the first operand."],["_mm_loadl_epi64","Loads 64-bit integer from memory into first element of returned vector."],["_mm_loadl_pd","Loads a double-precision value into the low-order bits of a 128-bit vector of `[2 x double]`. The high-order bits are copied from the high-order bits of the first operand."],["_mm_loadr_pd","Loads 2 double-precision (64-bit) floating-point elements from memory into the returned vector in reverse order. `mem_addr` must be aligned on a 16-byte boundary or a general-protection exception may be generated."],["_mm_loadu_pd","Loads 128-bits (composed of 2 packed double-precision (64-bit) floating-point elements) from memory into the returned vector. `mem_addr` does not need to be aligned on any particular boundary."],["_mm_loadu_si128","Loads 128-bits of integer data from memory into a new vector."],["_mm_madd_epi16","Multiplies and then horizontally add signed 16 bit integers in `a` and `b`."],["_mm_maskmoveu_si128","Conditionally store 8-bit integer elements from `a` into memory using `mask`."],["_mm_max_epi16","Compares packed 16-bit integers in `a` and `b`, and returns the packed maximum values."],["_mm_max_epu8","Compares packed unsigned 8-bit integers in `a` and `b`, and returns the packed maximum values."],["_mm_max_pd","Returns a new vector with the maximum values from corresponding elements in `a` and `b`."],["_mm_max_sd","Returns a new vector with the low element of `a` replaced by the maximum of the lower elements of `a` and `b`."],["_mm_mfence","Performs a serializing operation on all load-from-memory and store-to-memory instructions that were issued prior to this instruction."],["_mm_min_epi16","Compares packed 16-bit integers in `a` and `b`, and returns the packed minimum values."],["_mm_min_epu8","Compares packed unsigned 8-bit integers in `a` and `b`, and returns the packed minimum values."],["_mm_min_pd","Returns a new vector with the minimum values from corresponding elements in `a` and `b`."],["_mm_min_sd","Returns a new vector with the low element of `a` replaced by the minimum of the lower elements of `a` and `b`."],["_mm_move_epi64","Returns a vector where the low element is extracted from `a` and its upper element is zero."],["_mm_move_sd","Constructs a 128-bit floating-point vector of `[2 x double]`. The lower 64 bits are set to the lower 64 bits of the second parameter. The upper 64 bits are set to the upper 64 bits of the first parameter."],["_mm_movemask_epi8","Returns a mask of the most significant bit of each element in `a`."],["_mm_movemask_pd","Returns a mask of the most significant bit of each element in `a`."],["_mm_mul_epu32","Multiplies the low unsigned 32-bit integers from each packed 64-bit element in `a` and `b`."],["_mm_mul_pd","Multiplies packed double-precision (64-bit) floating-point elements in `a` and `b`."],["_mm_mul_sd","Returns a new vector with the low element of `a` replaced by multiplying the low elements of `a` and `b`."],["_mm_mulhi_epi16","Multiplies the packed 16-bit integers in `a` and `b`."],["_mm_mulhi_epu16","Multiplies the packed unsigned 16-bit integers in `a` and `b`."],["_mm_mullo_epi16","Multiplies the packed 16-bit integers in `a` and `b`."],["_mm_or_pd","Computes the bitwise OR of `a` and `b`."],["_mm_or_si128","Computes the bitwise OR of 128 bits (representing integer data) in `a` and `b`."],["_mm_packs_epi16","Converts packed 16-bit integers from `a` and `b` to packed 8-bit integers using signed saturation."],["_mm_packs_epi32","Converts packed 32-bit integers from `a` and `b` to packed 16-bit integers using signed saturation."],["_mm_packus_epi16","Converts packed 16-bit integers from `a` and `b` to packed 8-bit integers using unsigned saturation."],["_mm_pause","Provides a hint to the processor that the code sequence is a spin-wait loop."],["_mm_sad_epu8","Sum the absolute differences of packed unsigned 8-bit integers."],["_mm_set1_epi16","Broadcasts 16-bit integer `a` to all elements."],["_mm_set1_epi32","Broadcasts 32-bit integer `a` to all elements."],["_mm_set1_epi64x","Broadcasts 64-bit integer `a` to all elements."],["_mm_set1_epi8","Broadcasts 8-bit integer `a` to all elements."],["_mm_set1_pd","Broadcasts double-precision (64-bit) floating-point value a to all elements of the return value."],["_mm_set_epi16","Sets packed 16-bit integers with the supplied values."],["_mm_set_epi32","Sets packed 32-bit integers with the supplied values."],["_mm_set_epi64x","Sets packed 64-bit integers with the supplied values, from highest to lowest."],["_mm_set_epi8","Sets packed 8-bit integers with the supplied values."],["_mm_set_pd","Sets packed double-precision (64-bit) floating-point elements in the return value with the supplied values."],["_mm_set_pd1","Broadcasts double-precision (64-bit) floating-point value a to all elements of the return value."],["_mm_set_sd","Copies double-precision (64-bit) floating-point element `a` to the lower element of the packed 64-bit return value."],["_mm_setr_epi16","Sets packed 16-bit integers with the supplied values in reverse order."],["_mm_setr_epi32","Sets packed 32-bit integers with the supplied values in reverse order."],["_mm_setr_epi8","Sets packed 8-bit integers with the supplied values in reverse order."],["_mm_setr_pd","Sets packed double-precision (64-bit) floating-point elements in the return value with the supplied values in reverse order."],["_mm_setzero_pd","Returns packed double-precision (64-bit) floating-point elements with all zeros."],["_mm_setzero_si128","Returns a vector with all elements set to zero."],["_mm_shuffle_epi32","Shuffles 32-bit integers in `a` using the control in `IMM8`."],["_mm_shuffle_pd","Constructs a 128-bit floating-point vector of `[2 x double]` from two 128-bit vector parameters of `[2 x double]`, using the immediate-value parameter as a specifier."],["_mm_shufflehi_epi16","Shuffles 16-bit integers in the high 64 bits of `a` using the control in `IMM8`."],["_mm_shufflelo_epi16","Shuffles 16-bit integers in the low 64 bits of `a` using the control in `IMM8`."],["_mm_sll_epi16","Shifts packed 16-bit integers in `a` left by `count` while shifting in zeros."],["_mm_sll_epi32","Shifts packed 32-bit integers in `a` left by `count` while shifting in zeros."],["_mm_sll_epi64","Shifts packed 64-bit integers in `a` left by `count` while shifting in zeros."],["_mm_slli_epi16","Shifts packed 16-bit integers in `a` left by `IMM8` while shifting in zeros."],["_mm_slli_epi32","Shifts packed 32-bit integers in `a` left by `IMM8` while shifting in zeros."],["_mm_slli_epi64","Shifts packed 64-bit integers in `a` left by `IMM8` while shifting in zeros."],["_mm_slli_si128","Shifts `a` left by `IMM8` bytes while shifting in zeros."],["_mm_sqrt_pd","Returns a new vector with the square root of each of the values in `a`."],["_mm_sqrt_sd","Returns a new vector with the low element of `a` replaced by the square root of the lower element `b`."],["_mm_sra_epi16","Shifts packed 16-bit integers in `a` right by `count` while shifting in sign bits."],["_mm_sra_epi32","Shifts packed 32-bit integers in `a` right by `count` while shifting in sign bits."],["_mm_srai_epi16","Shifts packed 16-bit integers in `a` right by `IMM8` while shifting in sign bits."],["_mm_srai_epi32","Shifts packed 32-bit integers in `a` right by `IMM8` while shifting in sign bits."],["_mm_srl_epi16","Shifts packed 16-bit integers in `a` right by `count` while shifting in zeros."],["_mm_srl_epi32","Shifts packed 32-bit integers in `a` right by `count` while shifting in zeros."],["_mm_srl_epi64","Shifts packed 64-bit integers in `a` right by `count` while shifting in zeros."],["_mm_srli_epi16","Shifts packed 16-bit integers in `a` right by `IMM8` while shifting in zeros."],["_mm_srli_epi32","Shifts packed 32-bit integers in `a` right by `IMM8` while shifting in zeros."],["_mm_srli_epi64","Shifts packed 64-bit integers in `a` right by `IMM8` while shifting in zeros."],["_mm_srli_si128","Shifts `a` right by `IMM8` bytes while shifting in zeros."],["_mm_store1_pd","Stores the lower double-precision (64-bit) floating-point element from `a` into 2 contiguous elements in memory. `mem_addr` must be aligned on a 16-byte boundary or a general-protection exception may be generated."],["_mm_store_pd","Stores 128-bits (composed of 2 packed double-precision (64-bit) floating-point elements) from `a` into memory. `mem_addr` must be aligned on a 16-byte boundary or a general-protection exception may be generated."],["_mm_store_pd1","Stores the lower double-precision (64-bit) floating-point element from `a` into 2 contiguous elements in memory. `mem_addr` must be aligned on a 16-byte boundary or a general-protection exception may be generated."],["_mm_store_sd","Stores the lower 64 bits of a 128-bit vector of `[2 x double]` to a memory location."],["_mm_store_si128","Stores 128-bits of integer data from `a` into memory."],["_mm_storeh_pd","Stores the upper 64 bits of a 128-bit vector of `[2 x double]` to a memory location."],["_mm_storel_epi64","Stores the lower 64-bit integer `a` to a memory location."],["_mm_storel_pd","Stores the lower 64 bits of a 128-bit vector of `[2 x double]` to a memory location."],["_mm_storer_pd","Stores 2 double-precision (64-bit) floating-point elements from `a` into memory in reverse order. `mem_addr` must be aligned on a 16-byte boundary or a general-protection exception may be generated."],["_mm_storeu_pd","Stores 128-bits (composed of 2 packed double-precision (64-bit) floating-point elements) from `a` into memory. `mem_addr` does not need to be aligned on any particular boundary."],["_mm_storeu_si128","Stores 128-bits of integer data from `a` into memory."],["_mm_stream_pd","Stores a 128-bit floating point vector of `[2 x double]` to a 128-bit aligned memory location. To minimize caching, the data is flagged as non-temporal (unlikely to be used again soon)."],["_mm_stream_si128","Stores a 128-bit integer vector to a 128-bit aligned memory location. To minimize caching, the data is flagged as non-temporal (unlikely to be used again soon)."],["_mm_stream_si32","Stores a 32-bit integer value in the specified memory location. To minimize caching, the data is flagged as non-temporal (unlikely to be used again soon)."],["_mm_stream_si64","Stores a 64-bit integer value in the specified memory location. To minimize caching, the data is flagged as non-temporal (unlikely to be used again soon)."],["_mm_sub_epi16","Subtracts packed 16-bit integers in `b` from packed 16-bit integers in `a`."],["_mm_sub_epi32","Subtract packed 32-bit integers in `b` from packed 32-bit integers in `a`."],["_mm_sub_epi64","Subtract packed 64-bit integers in `b` from packed 64-bit integers in `a`."],["_mm_sub_epi8","Subtracts packed 8-bit integers in `b` from packed 8-bit integers in `a`."],["_mm_sub_pd","Subtract packed double-precision (64-bit) floating-point elements in `b` from `a`."],["_mm_sub_sd","Returns a new vector with the low element of `a` replaced by subtracting the low element by `b` from the low element of `a`."],["_mm_subs_epi16","Subtract packed 16-bit integers in `b` from packed 16-bit integers in `a` using saturation."],["_mm_subs_epi8","Subtract packed 8-bit integers in `b` from packed 8-bit integers in `a` using saturation."],["_mm_subs_epu16","Subtract packed unsigned 16-bit integers in `b` from packed unsigned 16-bit integers in `a` using saturation."],["_mm_subs_epu8","Subtract packed unsigned 8-bit integers in `b` from packed unsigned 8-bit integers in `a` using saturation."],["_mm_ucomieq_sd","Compares the lower element of `a` and `b` for equality."],["_mm_ucomige_sd","Compares the lower element of `a` and `b` for greater-than-or-equal."],["_mm_ucomigt_sd","Compares the lower element of `a` and `b` for greater-than."],["_mm_ucomile_sd","Compares the lower element of `a` and `b` for less-than-or-equal."],["_mm_ucomilt_sd","Compares the lower element of `a` and `b` for less-than."],["_mm_ucomineq_sd","Compares the lower element of `a` and `b` for not-equal."],["_mm_undefined_pd","Returns vector of type __m128d with undefined elements."],["_mm_undefined_si128","Returns vector of type __m128i with undefined elements."],["_mm_unpackhi_epi16","Unpacks and interleave 16-bit integers from the high half of `a` and `b`."],["_mm_unpackhi_epi32","Unpacks and interleave 32-bit integers from the high half of `a` and `b`."],["_mm_unpackhi_epi64","Unpacks and interleave 64-bit integers from the high half of `a` and `b`."],["_mm_unpackhi_epi8","Unpacks and interleave 8-bit integers from the high half of `a` and `b`."],["_mm_unpackhi_pd","The resulting `__m128d` element is composed by the low-order values of the two `__m128d` interleaved input elements, i.e.:"],["_mm_unpacklo_epi16","Unpacks and interleave 16-bit integers from the low half of `a` and `b`."],["_mm_unpacklo_epi32","Unpacks and interleave 32-bit integers from the low half of `a` and `b`."],["_mm_unpacklo_epi64","Unpacks and interleave 64-bit integers from the low half of `a` and `b`."],["_mm_unpacklo_epi8","Unpacks and interleave 8-bit integers from the low half of `a` and `b`."],["_mm_unpacklo_pd","The resulting `__m128d` element is composed by the high-order values of the two `__m128d` interleaved input elements, i.e.:"],["_mm_xor_pd","Computes the bitwise OR of `a` and `b`."],["_mm_xor_si128","Computes the bitwise XOR of 128 bits (representing integer data) in `a` and `b`."]]});