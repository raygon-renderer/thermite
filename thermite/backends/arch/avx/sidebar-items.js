initSidebarItems({"fn":[["_mm256_add_pd","Adds packed double-precision (64-bit) floating-point elements in `a` and `b`."],["_mm256_add_ps","Adds packed single-precision (32-bit) floating-point elements in `a` and `b`."],["_mm256_addsub_pd","Alternatively adds and subtracts packed double-precision (64-bit) floating-point elements in `a` to/from packed elements in `b`."],["_mm256_addsub_ps","Alternatively adds and subtracts packed single-precision (32-bit) floating-point elements in `a` to/from packed elements in `b`."],["_mm256_and_pd","Computes the bitwise AND of a packed double-precision (64-bit) floating-point elements in `a` and `b`."],["_mm256_and_ps","Computes the bitwise AND of packed single-precision (32-bit) floating-point elements in `a` and `b`."],["_mm256_andnot_pd","Computes the bitwise NOT of packed double-precision (64-bit) floating-point elements in `a`, and then AND with `b`."],["_mm256_andnot_ps","Computes the bitwise NOT of packed single-precision (32-bit) floating-point elements in `a` and then AND with `b`."],["_mm256_blend_pd","Blends packed double-precision (64-bit) floating-point elements from `a` and `b` using control mask `imm8`."],["_mm256_blend_ps","Blends packed single-precision (32-bit) floating-point elements from `a` and `b` using control mask `imm8`."],["_mm256_blendv_pd","Blends packed double-precision (64-bit) floating-point elements from `a` and `b` using `c` as a mask."],["_mm256_blendv_ps","Blends packed single-precision (32-bit) floating-point elements from `a` and `b` using `c` as a mask."],["_mm256_broadcast_pd","Broadcasts 128 bits from memory (composed of 2 packed double-precision (64-bit) floating-point elements) to all elements of the returned vector."],["_mm256_broadcast_ps","Broadcasts 128 bits from memory (composed of 4 packed single-precision (32-bit) floating-point elements) to all elements of the returned vector."],["_mm256_broadcast_sd","Broadcasts a double-precision (64-bit) floating-point element from memory to all elements of the returned vector."],["_mm256_broadcast_ss","Broadcasts a single-precision (32-bit) floating-point element from memory to all elements of the returned vector."],["_mm256_castpd128_pd256","Casts vector of type __m128d to type __m256d; the upper 128 bits of the result are undefined."],["_mm256_castpd256_pd128","Casts vector of type __m256d to type __m128d."],["_mm256_castpd_ps","Cast vector of type __m256d to type __m256."],["_mm256_castpd_si256","Casts vector of type __m256d to type __m256i."],["_mm256_castps128_ps256","Casts vector of type __m128 to type __m256; the upper 128 bits of the result are undefined."],["_mm256_castps256_ps128","Casts vector of type __m256 to type __m128."],["_mm256_castps_pd","Cast vector of type __m256 to type __m256d."],["_mm256_castps_si256","Casts vector of type __m256 to type __m256i."],["_mm256_castsi128_si256","Casts vector of type __m128i to type __m256i; the upper 128 bits of the result are undefined."],["_mm256_castsi256_pd","Casts vector of type __m256i to type __m256d."],["_mm256_castsi256_ps","Casts vector of type __m256i to type __m256."],["_mm256_castsi256_si128","Casts vector of type __m256i to type __m128i."],["_mm256_ceil_pd","Rounds packed double-precision (64-bit) floating point elements in `a` toward positive infinity."],["_mm256_ceil_ps","Rounds packed single-precision (32-bit) floating point elements in `a` toward positive infinity."],["_mm256_cmp_pd","Compares packed double-precision (64-bit) floating-point elements in `a` and `b` based on the comparison operand specified by `imm8`."],["_mm256_cmp_ps","Compares packed single-precision (32-bit) floating-point elements in `a` and `b` based on the comparison operand specified by `imm8`."],["_mm256_cvtepi32_pd","Converts packed 32-bit integers in `a` to packed double-precision (64-bit) floating-point elements."],["_mm256_cvtepi32_ps","Converts packed 32-bit integers in `a` to packed single-precision (32-bit) floating-point elements."],["_mm256_cvtpd_epi32","Converts packed double-precision (64-bit) floating-point elements in `a` to packed 32-bit integers."],["_mm256_cvtpd_ps","Converts packed double-precision (64-bit) floating-point elements in `a` to packed single-precision (32-bit) floating-point elements."],["_mm256_cvtps_epi32","Converts packed single-precision (32-bit) floating-point elements in `a` to packed 32-bit integers."],["_mm256_cvtps_pd","Converts packed single-precision (32-bit) floating-point elements in `a` to packed double-precision (64-bit) floating-point elements."],["_mm256_cvtsd_f64","Returns the first element of the input vector of `[4 x double]`."],["_mm256_cvtsi256_si32","Returns the first element of the input vector of `[8 x i32]`."],["_mm256_cvtss_f32","Returns the first element of the input vector of `[8 x float]`."],["_mm256_cvttpd_epi32","Converts packed double-precision (64-bit) floating-point elements in `a` to packed 32-bit integers with truncation."],["_mm256_cvttps_epi32","Converts packed single-precision (32-bit) floating-point elements in `a` to packed 32-bit integers with truncation."],["_mm256_div_pd","Computes the division of each of the 4 packed 64-bit floating-point elements in `a` by the corresponding packed elements in `b`."],["_mm256_div_ps","Computes the division of each of the 8 packed 32-bit floating-point elements in `a` by the corresponding packed elements in `b`."],["_mm256_dp_ps","Conditionally multiplies the packed single-precision (32-bit) floating-point elements in `a` and `b` using the high 4 bits in `imm8`, sum the four products, and conditionally return the sum using the low 4 bits of `imm8`."],["_mm256_extract_epi32","Extracts a 32-bit integer from `a`, selected with `imm8`."],["_mm256_extract_epi64","Extracts a 64-bit integer from `a`, selected with `imm8`."],["_mm256_extractf128_pd","Extracts 128 bits (composed of 2 packed double-precision (64-bit) floating-point elements) from `a`, selected with `imm8`."],["_mm256_extractf128_ps","Extracts 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from `a`, selected with `imm8`."],["_mm256_extractf128_si256","Extracts 128 bits (composed of integer data) from `a`, selected with `imm8`."],["_mm256_floor_pd","Rounds packed double-precision (64-bit) floating point elements in `a` toward negative infinity."],["_mm256_floor_ps","Rounds packed single-precision (32-bit) floating point elements in `a` toward negative infinity."],["_mm256_hadd_pd","Horizontal addition of adjacent pairs in the two packed vectors of 4 64-bit floating points `a` and `b`. In the result, sums of elements from `a` are returned in even locations, while sums of elements from `b` are returned in odd locations."],["_mm256_hadd_ps","Horizontal addition of adjacent pairs in the two packed vectors of 8 32-bit floating points `a` and `b`. In the result, sums of elements from `a` are returned in locations of indices 0, 1, 4, 5; while sums of elements from `b` are locations 2, 3, 6, 7."],["_mm256_hsub_pd","Horizontal subtraction of adjacent pairs in the two packed vectors of 4 64-bit floating points `a` and `b`. In the result, sums of elements from `a` are returned in even locations, while sums of elements from `b` are returned in odd locations."],["_mm256_hsub_ps","Horizontal subtraction of adjacent pairs in the two packed vectors of 8 32-bit floating points `a` and `b`. In the result, sums of elements from `a` are returned in locations of indices 0, 1, 4, 5; while sums of elements from `b` are locations 2, 3, 6, 7."],["_mm256_insert_epi16","Copies `a` to result, and inserts the 16-bit integer `i` into result at the location specified by `index`."],["_mm256_insert_epi32","Copies `a` to result, and inserts the 32-bit integer `i` into result at the location specified by `index`."],["_mm256_insert_epi64","Copies `a` to result, and insert the 64-bit integer `i` into result at the location specified by `index`."],["_mm256_insert_epi8","Copies `a` to result, and inserts the 8-bit integer `i` into result at the location specified by `index`."],["_mm256_insertf128_pd","Copies `a` to result, then inserts 128 bits (composed of 2 packed double-precision (64-bit) floating-point elements) from `b` into result at the location specified by `imm8`."],["_mm256_insertf128_ps","Copies `a` to result, then inserts 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from `b` into result at the location specified by `imm8`."],["_mm256_insertf128_si256","Copies `a` to result, then inserts 128 bits from `b` into result at the location specified by `imm8`."],["_mm256_lddqu_si256","Loads 256-bits of integer data from unaligned memory into result. This intrinsic may perform better than `_mm256_loadu_si256` when the data crosses a cache line boundary."],["_mm256_load_pd","Loads 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from memory into result. `mem_addr` must be aligned on a 32-byte boundary or a general-protection exception may be generated."],["_mm256_load_ps","Loads 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from memory into result. `mem_addr` must be aligned on a 32-byte boundary or a general-protection exception may be generated."],["_mm256_load_si256","Loads 256-bits of integer data from memory into result. `mem_addr` must be aligned on a 32-byte boundary or a general-protection exception may be generated."],["_mm256_loadu2_m128","Loads two 128-bit values (composed of 4 packed single-precision (32-bit) floating-point elements) from memory, and combine them into a 256-bit value. `hiaddr` and `loaddr` do not need to be aligned on any particular boundary."],["_mm256_loadu2_m128d","Loads two 128-bit values (composed of 2 packed double-precision (64-bit) floating-point elements) from memory, and combine them into a 256-bit value. `hiaddr` and `loaddr` do not need to be aligned on any particular boundary."],["_mm256_loadu2_m128i","Loads two 128-bit values (composed of integer data) from memory, and combine them into a 256-bit value. `hiaddr` and `loaddr` do not need to be aligned on any particular boundary."],["_mm256_loadu_pd","Loads 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from memory into result. `mem_addr` does not need to be aligned on any particular boundary."],["_mm256_loadu_ps","Loads 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from memory into result. `mem_addr` does not need to be aligned on any particular boundary."],["_mm256_loadu_si256","Loads 256-bits of integer data from memory into result. `mem_addr` does not need to be aligned on any particular boundary."],["_mm256_maskload_pd","Loads packed double-precision (64-bit) floating-point elements from memory into result using `mask` (elements are zeroed out when the high bit of the corresponding element is not set)."],["_mm256_maskload_ps","Loads packed single-precision (32-bit) floating-point elements from memory into result using `mask` (elements are zeroed out when the high bit of the corresponding element is not set)."],["_mm256_maskstore_pd","Stores packed double-precision (64-bit) floating-point elements from `a` into memory using `mask`."],["_mm256_maskstore_ps","Stores packed single-precision (32-bit) floating-point elements from `a` into memory using `mask`."],["_mm256_max_pd","Compares packed double-precision (64-bit) floating-point elements in `a` and `b`, and returns packed maximum values"],["_mm256_max_ps","Compares packed single-precision (32-bit) floating-point elements in `a` and `b`, and returns packed maximum values"],["_mm256_min_pd","Compares packed double-precision (64-bit) floating-point elements in `a` and `b`, and returns packed minimum values"],["_mm256_min_ps","Compares packed single-precision (32-bit) floating-point elements in `a` and `b`, and returns packed minimum values"],["_mm256_movedup_pd","Duplicate even-indexed double-precision (64-bit) floating-point elements from `a`, and returns the results."],["_mm256_movehdup_ps","Duplicate odd-indexed single-precision (32-bit) floating-point elements from `a`, and returns the results."],["_mm256_moveldup_ps","Duplicate even-indexed single-precision (32-bit) floating-point elements from `a`, and returns the results."],["_mm256_movemask_pd","Sets each bit of the returned mask based on the most significant bit of the corresponding packed double-precision (64-bit) floating-point element in `a`."],["_mm256_movemask_ps","Sets each bit of the returned mask based on the most significant bit of the corresponding packed single-precision (32-bit) floating-point element in `a`."],["_mm256_mul_pd","Multiplies packed double-precision (64-bit) floating-point elements in `a` and `b`."],["_mm256_mul_ps","Multiplies packed single-precision (32-bit) floating-point elements in `a` and `b`."],["_mm256_or_pd","Computes the bitwise OR packed double-precision (64-bit) floating-point elements in `a` and `b`."],["_mm256_or_ps","Computes the bitwise OR packed single-precision (32-bit) floating-point elements in `a` and `b`."],["_mm256_permute2f128_pd","Shuffles 256 bits (composed of 4 packed double-precision (64-bit) floating-point elements) selected by `imm8` from `a` and `b`."],["_mm256_permute2f128_ps","Shuffles 256 bits (composed of 8 packed single-precision (32-bit) floating-point elements) selected by `imm8` from `a` and `b`."],["_mm256_permute2f128_si256","Shuffles 128-bits (composed of integer data) selected by `imm8` from `a` and `b`."],["_mm256_permute_pd","Shuffles double-precision (64-bit) floating-point elements in `a` within 128-bit lanes using the control in `imm8`."],["_mm256_permute_ps","Shuffles single-precision (32-bit) floating-point elements in `a` within 128-bit lanes using the control in `imm8`."],["_mm256_permutevar_pd","Shuffles double-precision (64-bit) floating-point elements in `a` within 256-bit lanes using the control in `b`."],["_mm256_permutevar_ps","Shuffles single-precision (32-bit) floating-point elements in `a` within 128-bit lanes using the control in `b`."],["_mm256_rcp_ps","Computes the approximate reciprocal of packed single-precision (32-bit) floating-point elements in `a`, and returns the results. The maximum relative error for this approximation is less than 1.5*2^-12."],["_mm256_round_pd","Rounds packed double-precision (64-bit) floating point elements in `a` according to the flag `b`. The value of `b` may be as follows:"],["_mm256_round_ps","Rounds packed single-precision (32-bit) floating point elements in `a` according to the flag `b`. The value of `b` may be as follows:"],["_mm256_rsqrt_ps","Computes the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in `a`, and returns the results. The maximum relative error for this approximation is less than 1.5*2^-12."],["_mm256_set1_epi16","Broadcasts 16-bit integer `a` to all all elements of returned vector. This intrinsic may generate the `vpbroadcastw`."],["_mm256_set1_epi32","Broadcasts 32-bit integer `a` to all elements of returned vector. This intrinsic may generate the `vpbroadcastd`."],["_mm256_set1_epi64x","Broadcasts 64-bit integer `a` to all elements of returned vector. This intrinsic may generate the `vpbroadcastq`."],["_mm256_set1_epi8","Broadcasts 8-bit integer `a` to all elements of returned vector. This intrinsic may generate the `vpbroadcastb`."],["_mm256_set1_pd","Broadcasts double-precision (64-bit) floating-point value `a` to all elements of returned vector."],["_mm256_set1_ps","Broadcasts single-precision (32-bit) floating-point value `a` to all elements of returned vector."],["_mm256_set_epi16","Sets packed 16-bit integers in returned vector with the supplied values."],["_mm256_set_epi32","Sets packed 32-bit integers in returned vector with the supplied values."],["_mm256_set_epi64x","Sets packed 64-bit integers in returned vector with the supplied values."],["_mm256_set_epi8","Sets packed 8-bit integers in returned vector with the supplied values in reverse order."],["_mm256_set_m128","Sets packed __m256 returned vector with the supplied values."],["_mm256_set_m128d","Sets packed __m256d returned vector with the supplied values."],["_mm256_set_m128i","Sets packed __m256i returned vector with the supplied values."],["_mm256_set_pd","Sets packed double-precision (64-bit) floating-point elements in returned vector with the supplied values."],["_mm256_set_ps","Sets packed single-precision (32-bit) floating-point elements in returned vector with the supplied values."],["_mm256_setr_epi16","Sets packed 16-bit integers in returned vector with the supplied values in reverse order."],["_mm256_setr_epi32","Sets packed 32-bit integers in returned vector with the supplied values in reverse order."],["_mm256_setr_epi64x","Sets packed 64-bit integers in returned vector with the supplied values in reverse order."],["_mm256_setr_epi8","Sets packed 8-bit integers in returned vector with the supplied values in reverse order."],["_mm256_setr_m128","Sets packed __m256 returned vector with the supplied values."],["_mm256_setr_m128d","Sets packed __m256d returned vector with the supplied values."],["_mm256_setr_m128i","Sets packed __m256i returned vector with the supplied values."],["_mm256_setr_pd","Sets packed double-precision (64-bit) floating-point elements in returned vector with the supplied values in reverse order."],["_mm256_setr_ps","Sets packed single-precision (32-bit) floating-point elements in returned vector with the supplied values in reverse order."],["_mm256_setzero_pd","Returns vector of type __m256d with all elements set to zero."],["_mm256_setzero_ps","Returns vector of type __m256 with all elements set to zero."],["_mm256_setzero_si256","Returns vector of type __m256i with all elements set to zero."],["_mm256_shuffle_pd","Shuffles double-precision (64-bit) floating-point elements within 128-bit lanes using the control in `imm8`."],["_mm256_shuffle_ps","Shuffles single-precision (32-bit) floating-point elements in `a` within 128-bit lanes using the control in `imm8`."],["_mm256_sqrt_pd","Returns the square root of packed double-precision (64-bit) floating point elements in `a`."],["_mm256_sqrt_ps","Returns the square root of packed single-precision (32-bit) floating point elements in `a`."],["_mm256_store_pd","Stores 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from `a` into memory. `mem_addr` must be aligned on a 32-byte boundary or a general-protection exception may be generated."],["_mm256_store_ps","Stores 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from `a` into memory. `mem_addr` must be aligned on a 32-byte boundary or a general-protection exception may be generated."],["_mm256_store_si256","Stores 256-bits of integer data from `a` into memory. `mem_addr` must be aligned on a 32-byte boundary or a general-protection exception may be generated."],["_mm256_storeu2_m128","Stores the high and low 128-bit halves (each composed of 4 packed single-precision (32-bit) floating-point elements) from `a` into memory two different 128-bit locations. `hiaddr` and `loaddr` do not need to be aligned on any particular boundary."],["_mm256_storeu2_m128d","Stores the high and low 128-bit halves (each composed of 2 packed double-precision (64-bit) floating-point elements) from `a` into memory two different 128-bit locations. `hiaddr` and `loaddr` do not need to be aligned on any particular boundary."],["_mm256_storeu2_m128i","Stores the high and low 128-bit halves (each composed of integer data) from `a` into memory two different 128-bit locations. `hiaddr` and `loaddr` do not need to be aligned on any particular boundary."],["_mm256_storeu_pd","Stores 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from `a` into memory. `mem_addr` does not need to be aligned on any particular boundary."],["_mm256_storeu_ps","Stores 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from `a` into memory. `mem_addr` does not need to be aligned on any particular boundary."],["_mm256_storeu_si256","Stores 256-bits of integer data from `a` into memory. `mem_addr` does not need to be aligned on any particular boundary."],["_mm256_stream_pd","Moves double-precision values from a 256-bit vector of `[4 x double]` to a 32-byte aligned memory location. To minimize caching, the data is flagged as non-temporal (unlikely to be used again soon)."],["_mm256_stream_ps","Moves single-precision floating point values from a 256-bit vector of `[8 x float]` to a 32-byte aligned memory location. To minimize caching, the data is flagged as non-temporal (unlikely to be used again soon)."],["_mm256_stream_si256","Moves integer data from a 256-bit integer vector to a 32-byte aligned memory location. To minimize caching, the data is flagged as non-temporal (unlikely to be used again soon)"],["_mm256_sub_pd","Subtracts packed double-precision (64-bit) floating-point elements in `b` from packed elements in `a`."],["_mm256_sub_ps","Subtracts packed single-precision (32-bit) floating-point elements in `b` from packed elements in `a`."],["_mm256_testc_pd","Computes the bitwise AND of 256 bits (representing double-precision (64-bit) floating-point elements) in `a` and `b`, producing an intermediate 256-bit value, and set `ZF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise NOT of `a` and then AND with `b`, producing an intermediate value, and set `CF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `CF` to 0. Return the `CF` value."],["_mm256_testc_ps","Computes the bitwise AND of 256 bits (representing single-precision (32-bit) floating-point elements) in `a` and `b`, producing an intermediate 256-bit value, and set `ZF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise NOT of `a` and then AND with `b`, producing an intermediate value, and set `CF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `CF` to 0. Return the `CF` value."],["_mm256_testc_si256","Computes the bitwise AND of 256 bits (representing integer data) in `a` and `b`, and set `ZF` to 1 if the result is zero, otherwise set `ZF` to 0. Computes the bitwise NOT of `a` and then AND with `b`, and set `CF` to 1 if the result is zero, otherwise set `CF` to 0. Return the `CF` value."],["_mm256_testnzc_pd","Computes the bitwise AND of 256 bits (representing double-precision (64-bit) floating-point elements) in `a` and `b`, producing an intermediate 256-bit value, and set `ZF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise NOT of `a` and then AND with `b`, producing an intermediate value, and set `CF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `CF` to 0. Return 1 if both the `ZF` and `CF` values are zero, otherwise return 0."],["_mm256_testnzc_ps","Computes the bitwise AND of 256 bits (representing single-precision (32-bit) floating-point elements) in `a` and `b`, producing an intermediate 256-bit value, and set `ZF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise NOT of `a` and then AND with `b`, producing an intermediate value, and set `CF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `CF` to 0. Return 1 if both the `ZF` and `CF` values are zero, otherwise return 0."],["_mm256_testnzc_si256","Computes the bitwise AND of 256 bits (representing integer data) in `a` and `b`, and set `ZF` to 1 if the result is zero, otherwise set `ZF` to 0. Computes the bitwise NOT of `a` and then AND with `b`, and set `CF` to 1 if the result is zero, otherwise set `CF` to 0. Return 1 if both the `ZF` and `CF` values are zero, otherwise return 0."],["_mm256_testz_pd","Computes the bitwise AND of 256 bits (representing double-precision (64-bit) floating-point elements) in `a` and `b`, producing an intermediate 256-bit value, and set `ZF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise NOT of `a` and then AND with `b`, producing an intermediate value, and set `CF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `CF` to 0. Return the `ZF` value."],["_mm256_testz_ps","Computes the bitwise AND of 256 bits (representing single-precision (32-bit) floating-point elements) in `a` and `b`, producing an intermediate 256-bit value, and set `ZF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise NOT of `a` and then AND with `b`, producing an intermediate value, and set `CF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `CF` to 0. Return the `ZF` value."],["_mm256_testz_si256","Computes the bitwise AND of 256 bits (representing integer data) in `a` and `b`, and set `ZF` to 1 if the result is zero, otherwise set `ZF` to 0. Computes the bitwise NOT of `a` and then AND with `b`, and set `CF` to 1 if the result is zero, otherwise set `CF` to 0. Return the `ZF` value."],["_mm256_undefined_pd","Returns vector of type `__m256d` with undefined elements."],["_mm256_undefined_ps","Returns vector of type `__m256` with undefined elements."],["_mm256_undefined_si256","Returns vector of type __m256i with undefined elements."],["_mm256_unpackhi_pd","Unpacks and interleave double-precision (64-bit) floating-point elements from the high half of each 128-bit lane in `a` and `b`."],["_mm256_unpackhi_ps","Unpacks and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in `a` and `b`."],["_mm256_unpacklo_pd","Unpacks and interleave double-precision (64-bit) floating-point elements from the low half of each 128-bit lane in `a` and `b`."],["_mm256_unpacklo_ps","Unpacks and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in `a` and `b`."],["_mm256_xor_pd","Computes the bitwise XOR of packed double-precision (64-bit) floating-point elements in `a` and `b`."],["_mm256_xor_ps","Computes the bitwise XOR of packed single-precision (32-bit) floating-point elements in `a` and `b`."],["_mm256_zeroall","Zeroes the contents of all XMM or YMM registers."],["_mm256_zeroupper","Zeroes the upper 128 bits of all YMM registers; the lower 128-bits of the registers are unmodified."],["_mm256_zextpd128_pd256","Constructs a 256-bit floating-point vector of `[4 x double]` from a 128-bit floating-point vector of `[2 x double]`. The lower 128 bits contain the value of the source vector. The upper 128 bits are set to zero."],["_mm256_zextps128_ps256","Constructs a 256-bit floating-point vector of `[8 x float]` from a 128-bit floating-point vector of `[4 x float]`. The lower 128 bits contain the value of the source vector. The upper 128 bits are set to zero."],["_mm256_zextsi128_si256","Constructs a 256-bit integer vector from a 128-bit integer vector. The lower 128 bits contain the value of the source vector. The upper 128 bits are set to zero."],["_mm_broadcast_ss","Broadcasts a single-precision (32-bit) floating-point element from memory to all elements of the returned vector."],["_mm_cmp_pd","Compares packed double-precision (64-bit) floating-point elements in `a` and `b` based on the comparison operand specified by `imm8`."],["_mm_cmp_ps","Compares packed single-precision (32-bit) floating-point elements in `a` and `b` based on the comparison operand specified by `imm8`."],["_mm_cmp_sd","Compares the lower double-precision (64-bit) floating-point element in `a` and `b` based on the comparison operand specified by `imm8`, store the result in the lower element of returned vector, and copies the upper element from `a` to the upper element of returned vector."],["_mm_cmp_ss","Compares the lower single-precision (32-bit) floating-point element in `a` and `b` based on the comparison operand specified by `imm8`, store the result in the lower element of returned vector, and copies the upper 3 packed elements from `a` to the upper elements of returned vector."],["_mm_maskload_pd","Loads packed double-precision (64-bit) floating-point elements from memory into result using `mask` (elements are zeroed out when the high bit of the corresponding element is not set)."],["_mm_maskload_ps","Loads packed single-precision (32-bit) floating-point elements from memory into result using `mask` (elements are zeroed out when the high bit of the corresponding element is not set)."],["_mm_maskstore_pd","Stores packed double-precision (64-bit) floating-point elements from `a` into memory using `mask`."],["_mm_maskstore_ps","Stores packed single-precision (32-bit) floating-point elements from `a` into memory using `mask`."],["_mm_permute_pd","Shuffles double-precision (64-bit) floating-point elements in `a` using the control in `imm8`."],["_mm_permute_ps","Shuffles single-precision (32-bit) floating-point elements in `a` using the control in `imm8`."],["_mm_permutevar_pd","Shuffles double-precision (64-bit) floating-point elements in `a` using the control in `b`."],["_mm_permutevar_ps","Shuffles single-precision (32-bit) floating-point elements in `a` using the control in `b`."],["_mm_testc_pd","Computes the bitwise AND of 128 bits (representing double-precision (64-bit) floating-point elements) in `a` and `b`, producing an intermediate 128-bit value, and set `ZF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise NOT of `a` and then AND with `b`, producing an intermediate value, and set `CF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `CF` to 0. Return the `CF` value."],["_mm_testc_ps","Computes the bitwise AND of 128 bits (representing single-precision (32-bit) floating-point elements) in `a` and `b`, producing an intermediate 128-bit value, and set `ZF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise NOT of `a` and then AND with `b`, producing an intermediate value, and set `CF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `CF` to 0. Return the `CF` value."],["_mm_testnzc_pd","Computes the bitwise AND of 128 bits (representing double-precision (64-bit) floating-point elements) in `a` and `b`, producing an intermediate 128-bit value, and set `ZF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise NOT of `a` and then AND with `b`, producing an intermediate value, and set `CF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `CF` to 0. Return 1 if both the `ZF` and `CF` values are zero, otherwise return 0."],["_mm_testnzc_ps","Computes the bitwise AND of 128 bits (representing single-precision (32-bit) floating-point elements) in `a` and `b`, producing an intermediate 128-bit value, and set `ZF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise NOT of `a` and then AND with `b`, producing an intermediate value, and set `CF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `CF` to 0. Return 1 if both the `ZF` and `CF` values are zero, otherwise return 0."],["_mm_testz_pd","Computes the bitwise AND of 128 bits (representing double-precision (64-bit) floating-point elements) in `a` and `b`, producing an intermediate 128-bit value, and set `ZF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise NOT of `a` and then AND with `b`, producing an intermediate value, and set `CF` to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set `CF` to 0. Return the `ZF` value."],["_mm_testz_ps","Computes the bitwise AND of 128 bits (representing single-precision (32-bit) floating-point elements) in `a` and `b`, producing an intermediate 128-bit value, and set `ZF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise NOT of `a` and then AND with `b`, producing an intermediate value, and set `CF` to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set `CF` to 0. Return the `ZF` value."]],"struct":[["__m256","256-bit wide set of eight `f32` types, x86-specific"],["__m256d","256-bit wide set of four `f64` types, x86-specific"],["__m256i","256-bit wide integer vector type, x86-specific"]]});